# Functional Program Design in Scala
Functional Programming in Scala Specialisation - Functional Program Design in Scala

## About the specialisation

This Specialization provides a hands-on introduction to functional programming using the widespread programming language, Scala. It begins from the basic building blocks of the functional paradigm, first showing how to use these blocks to solve small problems, before building up to combining these concepts to architect larger functional programs. Functional paradigm facilitates parallel and distributed programming, and through a series of hands on examples and programming assignments, you'll learn how to analyze data sets small to large; from parallel programming on multicore architectures, to distributed programming on a cluster using Apache Spark.

A final capstone project will allow you to apply the skills you learned by building a large data-intensive application using real-world data.

## About the course

In this course you will learn how to apply the functional programming style in the design of larger applications. You'll get to know important new functional programming concepts, from lazy evaluation to structuring your libraries using monads. We'll work on larger and more involved examples, from state space exploration to random testing to discrete circuit simulators. Youâ€™ll also learn some best practices on how to write good Scala code in the real world.

Several parts of this course deal with the question how functional programming interacts with mutable state. We will explore the consequences of combining functions and state. We will also look at purely functional alternatives to mutable state, using infinite data structures or functional reactive programming.

Learning Outcomes. By the end of this course you will be able to:

1) recognize and apply design principles of functional programs,
2)  design functional libraries and their APIs,
3) competently combine functions and state in one program,
4) understand reasoning techniques for programs that combine 
   functions and state,
5) write simple functional reactive applications

## Syllabus 



*Week 1 :* We'll start by revisiting some concepts that we have learned from Principles of Functional Programming in Scala; collections, pattern matching, and functions. We'll then touch on for-comprehensions, a powerful way in Scala to traverse a list, process it, and return a new list. We'll see how to do queries with for-comprehensions as well as how the for-comprehension is "desugared" into calls to higher-order functions by the Scala compiler. Finally, we'll discuss what monads are, and how to verify that the monad laws are satisfied for a number of examples.

*Week 2 :* This week we'll revisit performance issues caused by combinatorial search, and we'll discover an important concept in functional programming that can these issues: laziness. We'll also learn a little bit about proofs on trees; in particular, we'll see how to extend structural induction to trees.

*Week 3 :* This week, we'll learn about state and side-effects. Through a rich example, we'll learn programming patterns for managing state in larger programs. We'll also learn about for-loops and while-loops in Scala.

*Week 4 :* This week we'll learn a number of important programming patterns via examples, starting with the observer pattern, and then going on to functional reactive programming. We'll learn how latency can be modeled as an effect, and how latency can be handled with Scala's monadic futures. We'll learn the important combinators on futures as well as how they can be composed to build up rich and responsive services.


**Assignment deatails are broken down in each week's folder.**
